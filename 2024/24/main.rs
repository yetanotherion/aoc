// Generated by asking o1 to translate main.py
// rustc -C opt-level=3 main.rs -o ./main
use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::{BufRead, BufReader};

// Operators, corresponding to Python's AND, XOR, OR = range(3)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum Operator {
    AND,
    XOR,
    OR,
}

// Read lines from a file
fn read_lines(fname: &str) -> Vec<String> {
    let file = File::open(fname).expect("Unable to open file");
    let reader = BufReader::new(file);
    reader
        .lines()
        .filter_map(|line| line.ok())
        .collect::<Vec<String>>()
}

// Parse input lines into gate values and a list of (left_name, op, right_name, target)
fn parse_input(lines: &[String]) -> (HashMap<String, i32>, Vec<(String, Operator, String, String)>) {
    let mut gate_values: HashMap<String, i32> = HashMap::new();
    let mut operators: Vec<(String, Operator, String, String)> = Vec::new();

    for line in lines {
        let l = line.trim();
        if l.is_empty() {
            continue;
        }
        if l.contains(':') {
            // name: value
            let parts: Vec<&str> = l.split(':').collect();
            if parts.len() == 2 {
                let name = parts[0].trim().to_string();
                let raw_value: i32 = parts[1].trim().parse().unwrap();
                gate_values.insert(name, raw_value);
            }
        } else {
            // "x AND y -> z", etc.
            let parts: Vec<&str> = l.split("->").collect();
            if parts.len() != 2 {
                continue;
            }
            let left = parts[0].trim();
            let target = parts[1].trim().to_string();
            let left_parts: Vec<&str> = left.split_whitespace().collect();
            if left_parts.len() == 3 {
                let left_name = left_parts[0].to_string();
                let raw_op = left_parts[1];
                let right_name = left_parts[2].to_string();

                let op = match raw_op {
                    "AND" => Operator::AND,
                    "OR"  => Operator::OR,
                    "XOR" => Operator::XOR,
                    _ => {
                        // fallback if you have other operators or invalid input
                        Operator::AND
                    }
                };
                operators.push((left_name, op, right_name, target));
            }
        }
    }
    (gate_values, operators)
}

// Build a "circuit" map: for each wire name, store the list of operators that depend on it
fn build_gate_circuit(
    wires: &[(String, Operator, String, String)],
) -> HashMap<String, Vec<(String, Operator, String, String)>> {
    let mut res: HashMap<String, Vec<(String, Operator, String, String)>> = HashMap::new();
    for (left_name, op, right_name, target) in wires {
        res.entry(left_name.clone())
            .or_insert_with(Vec::new)
            .push((left_name.clone(), *op, right_name.clone(), target.clone()));
        res.entry(right_name.clone())
            .or_insert_with(Vec::new)
            .push((left_name.clone(), *op, right_name.clone(), target.clone()));
    }
    res
}

// Build direct dependencies: target -> [left, right]
fn build_dependencies(
    wires: &[(String, Operator, String, String)],
) -> HashMap<String, (String, String)> {
    let mut res = HashMap::new();
    for (left_name, _op, right_name, target) in wires {
        res.insert(target.clone(), (left_name.clone(), right_name.clone()));
    }
    res
}

// Build transitive dependencies for a label
fn build_transitive_dependencies(
    dependencies: &HashMap<String, (String, String)>,
    label: &str,
) -> Option<HashSet<String>> {
    let mut res: HashSet<String> = HashSet::new();
    let mut to_explore: Vec<Vec<String>> = vec![vec![label.to_string()]];

    while let Some(curr_path) = to_explore.pop() {
        let curr = curr_path.last().unwrap().clone();
        let curr_deps = dependencies.get(&curr);
        if let Some((dep_left, dep_right)) = curr_deps {
            for dep in &[dep_left, dep_right] {
                res.insert(dep.to_string());
                // Cycle detection
                if curr_path.contains(dep) {
                    return None; // or Some(...) if you prefer to handle cycles
                }
                let mut new_path = curr_path.clone();
                new_path.push(dep.to_string());
                to_explore.push(new_path);
            }
        }
    }
    Some(res)
}

// Evaluate a single gate
fn eval_op(left: i32, op: Operator, right: i32) -> i32 {
    match op {
        Operator::AND => left & right,
        Operator::OR  => left | right,
        Operator::XOR => left ^ right,
    }
}

// Compute "z" by summing bits of z0, z1, z2, etc.
fn compute_z(gate_values: &HashMap<String, i32>, prefix: &str) -> i64 {
    let mut z_names: Vec<&String> = gate_values
        .keys()
        .filter(|k| k.starts_with(prefix))
        .collect();
    // sort by integer part after prefix "z"
    z_names.sort_by_key(|k| k[prefix.len()..].parse::<i32>().unwrap());

    let mut res: i64 = 0;
    let mut curr_mult: i64 = 1;
    for s in z_names {
        if let Some(val) = gate_values.get(s) {
            res += (*val as i64) * curr_mult;
            curr_mult *= 2;
        }
    }
    res
}

// Compute all gate values by propagating known values
fn compute_all(
    init_gate_values: &HashMap<String, i32>,
    wires: &[(String, Operator, String, String)],
) -> HashMap<String, i32> {
    // Copy initial gate values
    let mut gate_values: HashMap<String, i32> = init_gate_values.clone();
    let gate_circuits = build_gate_circuit(wires);
    let mut new_inputs: Vec<String> = gate_values.keys().cloned().collect();

    while !new_inputs.is_empty() {
        let next_input = new_inputs.remove(0);
        if let Some(gate_list) = gate_circuits.get(&next_input) {
            for (left, op, right, target) in gate_list {
                // If already computed, skip
                if gate_values.contains_key(target) {
                    continue;
                }
                let left_v = gate_values.get(left);
                let right_v = gate_values.get(right);
                if let (Some(&lv), Some(&rv)) = (left_v, right_v) {
                    let new_v = eval_op(lv, *op, rv);
                    gate_values.insert(target.to_string(), new_v);
                    new_inputs.push(target.to_string());
                }
            }
        }
    }
    gate_values
}

// question_one => compute_all + compute_z
fn question_one(
    init_gate_values: &HashMap<String, i32>,
    wires: &[(String, Operator, String, String)],
) -> i64 {
    let gate_values = compute_all(init_gate_values, wires);
    compute_z(&gate_values, "z")
}

// Swap helper: if curr_value == left, return right; if curr_value == right, return left; else curr_value
fn swap(curr_value: &str, left: &str, right: &str) -> String {
    if curr_value == left {
        right.to_string()
    } else if curr_value == right {
        left.to_string()
    } else {
        curr_value.to_string()
    }
}

// Rewire the circuit by swapping occurrences of left_wire and right_wire in the target
fn rewire(
    wires: &[(String, Operator, String, String)],
    left_wire: &str,
    right_wire: &str,
) -> Vec<(String, Operator, String, String)> {
    let mut new_wires = Vec::new();
    for (left, op, right, target) in wires {
        let new_target = swap(target, left_wire, right_wire);
        new_wires.push((left.clone(), *op, right.clone(), new_target));
    }
    new_wires
}

// Validate the circuit for i-th iteration
fn validate(wires: &[(String, Operator, String, String)], i: i32) -> bool {
    let curr_x_l = format!("x{:02}", i);
    let curr_y_l = format!("y{:02}", i);
    let before_x_l = format!("x{:02}", i - 1);
    let before_y_l = format!("y{:02}", i - 1);
    let expected_z_l = format!("z{:02}", i);

    // (curr_x, curr_y, before_x, before_y) -> expected_z
    let tests: Vec<((i32, i32, i32, i32), i32)> = vec![
        ((0, 0, 0, 0), 0),
        ((0, 0, 0, 1), 0),
        ((0, 0, 1, 0), 0),
        ((0, 0, 1, 1), 1),
        ((0, 1, 0, 0), 1),
        ((0, 1, 0, 1), 1),
        ((0, 1, 1, 0), 1),
        ((0, 1, 1, 1), 0),
        ((1, 0, 0, 0), 1),
        ((1, 0, 0, 1), 1),
        ((1, 0, 1, 0), 1),
        ((1, 0, 1, 1), 0),
        ((1, 1, 0, 0), 0),
        ((1, 1, 0, 1), 0),
        ((1, 1, 1, 0), 0),
        ((1, 1, 1, 1), 1),
    ];

    // For all "before" < i, set x0..x(i-1), y0..y(i-1) = 0
    let mut i_gate_values = HashMap::new();
    for before in 0..(i - 1) {
        i_gate_values.insert(format!("x{:02}", before), 0);
        i_gate_values.insert(format!("y{:02}", before), 0);
    }

    for ((curr_x, curr_y, before_x, before_y), expected_z) in tests {
        let mut gate_values = i_gate_values.clone();
        gate_values.insert(curr_x_l.clone(), curr_x);
        gate_values.insert(curr_y_l.clone(), curr_y);
        gate_values.insert(before_x_l.clone(), before_x);
        gate_values.insert(before_y_l.clone(), before_y);

        let new_gate_values = compute_all(&gate_values, wires);
        let z_val = new_gate_values.get(&expected_z_l);
        if z_val.is_none() || z_val.unwrap() != &expected_z {
            return false;
        }
    }
    true
}

// question_two => tries to "fix" wires by swapping
fn question_two(wires: &[(String, Operator, String, String)], max_i: i32) -> String {
    let mut swaps: Vec<(String, String)> = Vec::new();
    let mut curr_wire = wires.to_vec();
    let dependencies = build_dependencies(wires);

    // We only consider candidates that do not start with x or y
    let mut candidates: Vec<String> = dependencies
        .keys()
        .filter(|k| !(k.starts_with("x") || k.starts_with("y")))
        .cloned()
        .collect();
    // For each i from 1..max_i
    for i in 1..max_i {
        // If this is already valid, remove transitive dependencies from the candidate list
        if validate(&curr_wire, i) {
            if let Some(transitive) = build_transitive_dependencies(&dependencies, &format!("z{:02}", i)) {
                candidates.retain(|k| !transitive.contains(k));
            }
            continue;
        }
        // Otherwise, try possible swaps
        let mut swap_found = false;
        let mut idx = 0;
        while idx < candidates.len() && !swap_found {
            let a = candidates[idx].clone();
            for b_idx in (idx + 1)..candidates.len() {
                let b = candidates[b_idx].clone();
                let new_wire = rewire(&curr_wire, &a, &b);
                if validate(&new_wire, i) {
                    curr_wire = new_wire;
                    swaps.push((a.clone(), b.clone()));
                    if let Some(transitive) = build_transitive_dependencies(&dependencies, &format!("z{:02}", i)) {
                        candidates.retain(|k| !transitive.contains(k));
                    }
                    swap_found = true;
                    break;
                }
            }
            idx += 1;
        }
    }

    // Double-check final circuit
    for i in 1..max_i {
        assert!(validate(&curr_wire, i));
    }

    // Return sorted list of swapped wires
    let mut res: Vec<String> = Vec::new();
    for (a, b) in &swaps {
        res.push(a.clone());
        res.push(b.clone());
    }
    res.sort();
    res.join(",")
}

fn main() {
    let raw_input = read_lines("input.txt");
    let (gate_values, wires) = parse_input(&raw_input);
    println!("{}", question_one(&gate_values, &wires));
    println!("{}", question_two(&wires, 45));
}
