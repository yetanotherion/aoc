// Generated by asking o1 to translate main.py
// rustc -C opt-level=3 main.rs -o ./main
use std::collections::HashSet;
use std::fs;

type Dir = (i32, i32);
type Pos = (i32, i32);
type State = (Pos, Dir);

const UP: Dir = (-1, 0);
const RIGHT: Dir = (0, 1);
const DOWN: Dir = (1, 0);
const LEFT: Dir = (0, -1);

fn read_input(fname: &str) -> Vec<Vec<char>> {
    let content = fs::read_to_string(fname).expect("Failed to read input file");
    let lines: Vec<Vec<char>> = content
        .lines()
        .map(|l| l.chars().collect())
        .collect();
    lines
}

fn find_starting_point(grid: &[Vec<char>]) -> Pos {
    for (i, line) in grid.iter().enumerate() {
        for (j, &elt) in line.iter().enumerate() {
            if elt == '^' {
                return (i as i32, j as i32);
            }
        }
    }
    panic!("No starting point '^' found in the grid.");
}

fn rotate(curr_dir: Dir) -> Dir {
    match curr_dir {
        UP => RIGHT,
        RIGHT => DOWN,
        DOWN => LEFT,
        LEFT => UP,
        _ => unreachable!(),
    }
}

fn in_bounds(grid: &[Vec<char>], i: i32, j: i32) -> bool {
    i >= 0 && i < grid.len() as i32 && j >= 0 && j < grid[0].len() as i32
}

fn browse_all(grid: &[Vec<char>]) -> HashSet<State> {
    let (mut curr_i, mut curr_j) = find_starting_point(grid);
    let mut curr_dir = UP;
    let mut visited: HashSet<State> = HashSet::new();
    visited.insert(((curr_i, curr_j), curr_dir));

    loop {
        let next_i = curr_i + curr_dir.0;
        let next_j = curr_j + curr_dir.1;

        if !in_bounds(grid, next_i, next_j) {
            return visited;
        }

        let next_elt = grid[next_i as usize][next_j as usize];
        if next_elt == '#' {
            curr_dir = rotate(curr_dir);
            continue;
        }
        curr_i = next_i;
        curr_j = next_j;
        visited.insert(((curr_i, curr_j), curr_dir));
    }
}

fn question_one(grid: &[Vec<char>]) -> usize {
    let visited = browse_all(grid);
    // Extract positions (ignoring direction) and get unique count
    let unique_positions: HashSet<Pos> = visited.iter().map(|(pos, _)| *pos).collect();
    unique_positions.len()
}

fn browse_until_cycle(
    grid: &[Vec<char>],
    start: State,
    visited: &HashSet<State>,
    fake: Pos,
) -> bool {
    let ((mut curr_i, mut curr_j), mut curr_dir) = start;
    let mut new_visited = visited.clone();
    new_visited.insert(start);

    loop {
        let next_i = curr_i + curr_dir.0;
        let next_j = curr_j + curr_dir.1;

        if !in_bounds(grid, next_i, next_j) {
            return false;
        }

        let next_elt = grid[next_i as usize][next_j as usize];
        if next_elt == '#' || (next_i, next_j) == fake {
            curr_dir = rotate(curr_dir);
            continue;
        }

        curr_i = next_i;
        curr_j = next_j;
        let new_state = ((curr_i, curr_j), curr_dir);

        if new_visited.contains(&new_state) {
            return true;
        }
        new_visited.insert(new_state);
    }
}

fn question_two(grid: &[Vec<char>]) -> usize {
    let (mut curr_i, mut curr_j) = find_starting_point(grid);
    let mut curr_dir = UP;

    let mut visited: HashSet<State> = HashSet::new();
    visited.insert(((curr_i, curr_j), UP));

    let mut obstacles: HashSet<Pos> = HashSet::new();
    let mut seen: HashSet<Pos> = HashSet::new();
    seen.insert((curr_i, curr_j));

    loop {
        let next_i = curr_i + curr_dir.0;
        let next_j = curr_j + curr_dir.1;

        if !in_bounds(grid, next_i, next_j) {
            return obstacles.len();
        }

        let next_elt = grid[next_i as usize][next_j as usize];
        if next_elt == '#' {
            curr_dir = rotate(curr_dir);
            continue;
        }

        if !seen.contains(&(next_i, next_j)) {
            // Check for cycles if we put a fake obstacle
            let fake_state = ((curr_i, curr_j), rotate(curr_dir));
            if browse_until_cycle(grid, fake_state, &visited, (next_i, next_j)) {
                obstacles.insert((next_i, next_j));
            }
        }

        curr_i = next_i;
        curr_j = next_j;
        seen.insert((curr_i, curr_j));
        visited.insert(((curr_i, curr_j), curr_dir));
    }
}

fn main() {
    let game_input = read_input("input.txt");
    println!("{}", question_one(&game_input));
    println!("{}", question_two(&game_input));
}
