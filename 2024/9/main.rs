// Generated by asking o1 to translate main.py
// rustc -C opt-level=3 main.rs -o ./main

use std::fs;

#[derive(Debug, Clone)]
struct FreeSlot {
    idx: usize,
    len: usize,
}

fn read_input(fname: &str) -> String {
    let content = fs::read_to_string(fname).expect("Could not read input file");
    content.trim().to_string()
}

fn parse_input(raw_input: &str) -> (Vec<usize>, Vec<usize>) {
    let mut raw = raw_input.to_string();
    // If length is odd, append '0'
    if raw.len() % 2 == 1 {
        raw.push('0');
    }

    let chars: Vec<char> = raw.chars().collect();
    let mut file_blocks = Vec::new();
    let mut free_blocks = Vec::new();

    // Iterate two chars at a time
    for chunk in chars.chunks(2) {
        let occupied_str: String = chunk[0].to_string();
        let free_str: String = chunk[1].to_string();
        let nb_occupied = occupied_str.parse::<usize>().unwrap();
        let nb_free = free_str.parse::<usize>().unwrap();
        file_blocks.push(nb_occupied);
        free_blocks.push(nb_free);
    }

    (file_blocks, free_blocks)
}

fn question_one(mut game_input: (Vec<usize>, Vec<usize>)) -> u64 {
    let (mut file_blocks, free_blocks) = (game_input.0, game_input.1);

    let mut i = 0usize;
    let mut multiplier_idx = 0u64;
    let mut res = 0u64;

    while i < file_blocks.len() {
        let curr_file = file_blocks[i];
        let curr_free = free_blocks[i];

        // For each occupied block in current file block
        for _ in 0..curr_file {
            res += (i as u64) * multiplier_idx;
            multiplier_idx += 1;
        }

        let mut remaining_free = curr_free;
        if i == file_blocks.len() - 1 {
            i += 1;
            continue;
        }

        // Move free space blocks from the end to fill the current free space
        while remaining_free > 0 {
            let last_idx = file_blocks.len() - 1;
            let last_elt = file_blocks.pop().unwrap();
            let taken = std::cmp::min(last_elt, remaining_free);
            if last_elt <= remaining_free {
                remaining_free -= last_elt;
            } else {
                file_blocks.push(last_elt - remaining_free);
                remaining_free = 0;
            }
            for _ in 0..taken {
                res += (last_idx as u64) * multiplier_idx;
                multiplier_idx += 1;
            }
        }

        i += 1;
    }

    res
}

fn question_two(mut game_input: (Vec<usize>, Vec<usize>)) -> u64 {
    let (mut file_blocks, mut free_blocks) = (game_input.0, game_input.1);

    let mut moved_slots: Vec<Vec<FreeSlot>> = vec![vec![]; free_blocks.len()];
    let mut moved_block = vec![false; file_blocks.len()];

    let mut j = file_blocks.len() as isize - 1;
    while j >= 0 {
        let j_usize = j as usize;
        let mut curr_free_slot_idx = 0;
        let curr = file_blocks[j_usize];

        while curr_free_slot_idx < j_usize {
            let remaining = free_blocks[curr_free_slot_idx];
            if remaining >= curr {
                moved_block[j_usize] = true;
                moved_slots[curr_free_slot_idx].push(FreeSlot {
                    idx: j_usize,
                    len: curr,
                });
                let new_remaining = remaining - curr;
                free_blocks[curr_free_slot_idx] = new_remaining;
                break;
            } else {
                curr_free_slot_idx += 1;
            }
        }

        j -= 1;
    }

    let mut res = 0u64;
    let mut mult_idx = 0u64;

    for (i, &file_block) in file_blocks.iter().enumerate() {
        // Blocks that were not moved
        for _ in 0..file_block {
            if !moved_block[i] {
                res += (i as u64) * mult_idx;
            }
            mult_idx += 1;
        }

        // Blocks that were moved into free slots
        for moved_slot in &moved_slots[i] {
            for _ in 0..moved_slot.len {
                res += (moved_slot.idx as u64) * mult_idx;
                mult_idx += 1;
            }
        }

        // Remaining free blocks at this index
        if free_blocks[i] > 0 {
            mult_idx += free_blocks[i] as u64;
        }
    }

    res
}

fn main() {
    let raw_input = read_input("input.txt");
    let game_input = parse_input(&raw_input);

    let q1_input = (game_input.0.clone(), game_input.1.clone());
    let q2_input = (game_input.0.clone(), game_input.1.clone());

    println!("{}", question_one(q1_input));
    println!("{}", question_two(q2_input));
}
